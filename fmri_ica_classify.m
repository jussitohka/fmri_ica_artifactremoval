% FMRI_ICA_CLASSIFY Version 1.1.2:
% Classifies the ICA components of an fMR image to "signal" and "noise" for artifact removal
% Uses global decision tree classifier generated by the train_fmri_multithr-function
% Copyright (C) 2005 - 2011 Jussi Tohka, Department of Signal Processing, Tampere University of
% Technology, P.O. Box 553, FIN-33101, Finland
% E-mail: jussi.tohka@tut.fi
%
% The method is described in:
% J. Tohka , K. Foerde, A.R. Aron, S. M. Tom, A.W. Toga, and
% R.A. Poldrack. 
% Automatic Independent Component Labeling for Artifact Removal in fMRI.
% NeuroImage ,Volume 39, Issue 3, 1 February 2008, Pages 1227-1245, 2008. 
% http://dx.doi.org/10.1016/j.neuroimage.2007.10.013
% ----------------------------------------------------------------------------
% Version 1.1 23rd Jan 2008: The possibility to read gzipped files was added (JT). 
% Version 1.1.1. 19th Nov 2009: 1) Updated the function fmri_readicanii to use 
%               read_untouch_nii instead of read_nii of the previous version. 
%               This reflects changes to the NIFTI-Matlab Toolbox by Jimmy Shen,
%               the current version is up-to-date with the NIFTI Toolbox dated 
%               20090909. (JT) 
%               2) Corrected a bug in the parameter passing to fmri_write_icafilter
%                  Passing an empty matrix as output directory should now work 
%                  as documented. 
%               3) Corrected a bug related to the use of Matlab function 'exist';
%                  This appears at least with Matlab version higher than 7.8
% Version 1.1.2 18th Feb 2011: 1) Updated fmri_writeicafilter to use the command
%                 'fsl_regfilt' for denoising in accordance with the most current 
%                  FSL releases. Note that the results should be the same independent 
%                  of the command used, and the old command still seems to work with 
%                  most FSL releases, altough newer releases issue a warning when the 
%                  old command is used. There seems to be slight differences on how the files
%                  are masked, but these should have no practical meaning. In addition, there are
%                  differences in file naming conventions.  
%                  2) Denoise = 'true' should now work for also in new Matlab versions  
% ----------------------------------------------------------------------------
% Permission to use, copy, modify, and distribute this software 
% for any purpose and without fee is hereby
% granted, provided that the above copyright notice appear in all
% copies.  The author and Tampere University of Technology make no representations
% about the suitability of this software for any purpose.  It is
% provided "as is" without express or implied warranty.
% ----------------------------------------------------------------------------
% Requires functions       : fmri_features4
%
% ----------------------------------------------------------------------------
%
% Usage   :  [filter_str,rejected,accepted,cls] =
% 
% fmri_ica_classify(ica_directory,classifier,blocked,denoise,[odir],[tr],[flimits]);         
%                          
% ************************************************************************************
% Input    :    ica_directory : the directory where Melodic output lies    
%               classifier    : the classifier with the desired Neyman Pearson threshold. 
%               blocked       : 0 if event related design (target
%                               frequency assumed to be 0.01 Hz -  0.1 Hz)
%                             : 1 if blocked design with the target frequency of 10 cycles
%                             : n if blocked design with the target frequency of n cycles
%               denoise       : 'false' (default) this function only returns the desired string
%                             : 'true'  this function executes the desired melodic filtering command
%                             : 'file' produces a batch script named
%                                      ica_denoise.sh that, when run,
%                                      executes the filtering command. 
%                                      The file is written in the working
%                                      directory.                
%              odir(optional) : sets the output directory of the melodic
%                               filtering. If you want to set the tr and
%                               flimits parameters but keep the default
%                               melodic filtering give an empty matrix.  
%              tr(optional)  : The repetition time (TR) in ms. Defaults to
%                              2000. If you're using a considerably
%                              different TR than 2000, the classifier may
%                              not work well for the event related case. 
%              flimits(optional) : A 3 component vector which sets 1) low
%                                  frequency limit, 2) the lower limit of the target
%                                  frequency and 3) the upper limit of the target
%                                  frequency. All should be given in Hertzs. 2) and 3) are
%                                  ignored for the blocked designs.   
% ************************************************************************************
% Output   : filter_str      : string containing the melodic filtering command
%          :   rejected      : the rejected components
%          :   accepted      : the accepted components
%                   cls      : 0 for each accepted compo and 1 for each rejected compo
% 
% ***********************************************************************************

function [filter_str,rejected,accepted,cls] = fmri_ica_classify(ica_directory,classifier,blocked,denoise,varargin)
  len = length(ica_directory);
  if ica_directory(len) == '/'
    ica_directory = ica_directory;
  else
    ica_directory = strcat(ica_directory,'/');
    len = len + 1;
  end
  
  [img,sig,sigFT,mask] = fmri_readicanii(ica_directory);
  sz = size(img);
  st = zeros(3,3,3);
  st(2,:,:) = 1;
  st(:,2,:) = 1;
  st(:,:,2) = 1;
  mask = double(mask);
  img = double(img);
  bsmask = mask - erode3D(mask,st);
  bsind = find(bsmask(:) > 0);
  brain = erode3D(mask,ones(3,3,3));
  brainind = find(brain(:) > 0);
  if length(varargin) > 1
    tr = varargin{2};
  else 
    tr = 2000;
  end
  if length(varargin) > 2
    flimits = varargin{3};
    flimits = flimits*((tr/1000)*length(sig));
  else
    flimits = [0.005 0.01 0.095];
    flimits = flimits*((tr/1000)*length(sig));
  end
  flimits(1) = round(flimits(1) + 1);
  flimits(2) = ceil(flimits(2));
  flimits(3) = round(flimits(3));
    
  for i = 1:sz(4)
    features(i,:) = fmri_features4(img(:,:,:,i),sigFT(i,:),sig(i,:),mask,bsind,brainind,blocked,flimits);
  end
 
  
% Classifier: 
% each row (of 4) gives the classification result to accepted (0) 
% or rejected (1) corresponding individual classifiers 
  totalclasses = zeros(sz(4),4);
  cls = zeros(sz(1),1);

  if ischar(classifier)
    if exist(classifier,'file') | exist(strcat(classifier,'.mat'),'file')
      load(classifier)
      classifierfn = classifier;
      classifier = gdt;
    end
  end  
%  4 component classifiers:
  totalclasses(:,1) = (features(:,2) < classifier.tra(1)) & (features(:,4) < classifier.tra(2)) & (features(:,6) < classifier.tra(3));
  totalclasses(:,2) = (features(:,1) < classifier.trb(1)) & ((features(:,2) < classifier.trb(2)) | (features(:,3) < classifier.trb(3)));
  totalclasses(:,3) = (features(:,2) < classifier.trc(1)) & (features(:,4) < classifier.trc(2)) & (features(:,6) < classifier.trc(3));
  totalclasses(:,4) = (features(:,2) < classifier.trd(1)) & (features(:,4) < classifier.trd(2)) & (features(:,5) < classifier.trd(3));
% if an IC if rejected by some component classfier then it is rejected  
  cls = sum(totalclasses,2) > 0;
  rejected = find(cls == 1);
  accepted = find(cls == 0);
  % this is little bit questionable but prevents nasty errors when running the function
  if(length(rejected) == 0)
    [mr rejected] = min(sum(features./(repmat(sqrt(var(features)),sz(4),1)),2));
  end
  % Please read the premeable of fmri_writeicafilter function to see if
  % you'll have to edit these lines according to your own file naming
  % conventions.  
  if length(varargin) > 0  
    filter_str = fmri_writeicafilter(ica_directory,rejected,varargin{1});
  else
    filter_str = fmri_writeicafilter(ica_directory,rejected);
  end
  
  if(strcmp(denoise,'true'))
    unix(filter_str);
  end
  if(strcmp(denoise,'file'))
    fid = fopen('ica_denoise.sh','wt');
    fprintf(fid,'%s \n',filter_str);
    fclose(fid);
  end

% **************************************************************************************
% Reads the component maps, IC time courses, IC power spectra, and the brain mask from Melodic output
% requires : Tools for NIfTI MRI by Jimmy Shen 
% http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=8797&objectType=FILE
% **************************************************************************************  
  
function [img,sig,sigFT,mask] = fmri_readicanii(directory)

  % The file names. You may need to change these to correspond to
% your settings of the melodic.

ICmapfn = 'melodic_IC';
maskfn = 'mask';
ICtcfn = 'melodic_mix';
ICtcftfn = 'melodic_FTmix';


len = length(directory);
if directory(len) == '/'
  ICdir = directory;
else
  ICdir = strcat(directory,'/');
end

hdr_zipped = 0;
if exist(strcat(ICdir,ICmapfn,'.nii'),'file') 
  niifile = load_untouch_nii(strcat(ICdir,ICmapfn,'.nii'));
elseif exist(strcat(ICdir,ICmapfn,'.nii.gz'),'file')
  unix(['gzip -d ',strcat(ICdir,ICmapfn,'.nii.gz')]);
  niifile = load_untouch_nii(strcat(ICdir,ICmapfn,'.nii'));
  unix(['gzip ',strcat(ICdir,ICmapfn,'.nii')]);
elseif exist(strcat(ICdir,ICmapfn,'.img.gz'),'file')
  unix(['gzip -d ',strcat(ICdir,ICmapfn,'.img.gz')]); 
  if exist(strcat(ICdir,ICmapfn,'.hdr.gz'),'file') 
    hdr_zipped = 1;
    unix(['gzip -d ',strcat(ICdir,ICmapfn,'.hdr.gz')]); 
  end
  niifile = load_untouch_nii(strcat(ICdir,ICmapfn));
  unix(['gzip ',strcat(ICdir,ICmapfn,'.img')]); 
  if hdr_zipped 
    unix(['gzip ',strcat(ICdir,ICmapfn,'.hdr')]); 
  end
else
  niifile = load_untouch_nii(strcat(ICdir,ICmapfn));
end
img = niifile.img;

hdr_zipped = 0;
if exist(strcat(ICdir,maskfn,'.nii'),'file') 
  niifile = load_untouch_nii(strcat(ICdir,maskfn,'.nii'));
elseif exist(strcat(ICdir,maskfn,'.nii.gz'),'file')
  unix(['gzip -d ',strcat(ICdir,maskfn,'.nii.gz')]);
  niifile = load_untouch_nii(strcat(ICdir,maskfn,'.nii'));
  unix(['gzip ',strcat(ICdir,maskfn,'.nii')]);
elseif exist(strcat(ICdir,maskfn,'.img.gz'),'file')
  unix(['gzip -d ',strcat(ICdir,maskfn,'.img.gz')]); 
  if exist(strcat(ICdir,maskfn,'.hdr.gz'),'file') 
    hdr_zipped = 1;
    unix(['gzip -d ',strcat(ICdir,maskfn,'.hdr.gz')]); 
  end
  niifile = load_untouch_nii(strcat(ICdir,maskfn));
  unix(['gzip ',strcat(ICdir,maskfn,'.img')]); 
  if hdr_zipped 
    unix(['gzip ',strcat(ICdir,maskfn,'.hdr')]); 
  end
else
  niifile = load_untouch_nii(strcat(ICdir,maskfn));
end
mask = niifile.img;
sz = size(img);

fid = fopen(strcat(ICdir,ICtcfn),'rt');
[sig,count] = fscanf(fid,'%f');
sig = reshape(sig,sz(4),count/sz(4));
fclose(fid);
fid = fopen(strcat(ICdir,ICtcftfn),'rt');
[sigFT,count] = fscanf(fid,'%f');
sigFT = reshape(sigFT,sz(4),count/sz(4));
fclose(fid);
  


% *************************************************************************************
% Takes the melodic IC directory and a vector of rejected component indexes as the input 
% Returns a string containing the filtering command. 
% NOTE THAT it is assumed that the full path name of the original image
% can be deduced based on the name of the Melodic output directory. You
% can override this by giving the full path name as an optional argument
% to the function.
% 
% Usage : filter_str = fmri_write_icafilter(icadir,rejected,[outputdir],[digitsoff],[base_image])
%                      
% Input:   icadir    : the directory where Melodic output lies
%          rejected  : A vector of indexes of rejected components
%          outputdir : (optional) the directory where to save the
%                      filtered timeseries. Assumed to be subdirectory 
%                      of the Melodic output directory.  Defaults to
%                      'filtered_data.ica.auto'. Give an empty matrix if
%                      you want to keep the default but to tune the one
%                      of the two succeeding input args.       
%          digitsoff : (optional) the number of characters to take off
%                      from the Melodic output directory name to get the
%                      original image name. Defaults to 5. This means if
%                      Melodic output directory is
%                      /data/brainscan0001_mcf.ica/ then the original
%                      image name is /data/brainscan0001_mcf  (without
%                      file extension)               
%          base_image : (optional) if the original image name cannot be
%                      deduced from the name of the Melodic output
%                      directory, you'll have to give the full name of
%                      the original image here (including full path
%                      excluding identifier). Providing this argument
%                      causes the program to ignore digitsoff argument.  
% *************************************************************************************

function filter_str = fmri_writeicafilter(icadir,rejected,varargin)

len = length(icadir);
if icadir(len) == '/'
  icadir = icadir;
else
  icadir = strcat(icadir,'/');
  len = len + 1;
end
k = length(icadir) - 1;

while icadir(k) ~= '/'
  k = k - 1;
end
if length(varargin) > 0
  if isempty(varargin{1})
    outputdir =  strcat(icadir(1:k),'filtered_data.ica.auto');
  else
    outputdir = strcat(icadir(1:k),varargin{1});
  end
else
  outputdir = strcat(icadir(1:k),'filtered_data.ica.auto');
end

if length(varargin) > 1
  if length(varargin) == 2
    base_image = icadir(1:(len - varargin{2}));
  else
    base_image = varargin{3};
  end  
else
  base_image = icadir(1:(len - 5));
end
filter_str = 'fsl_regfilt -i ';
filter_str = strcat([filter_str,base_image,' -v -o ',outputdir, ' -d ',icadir,'melodic_mix -f']);
filter_str =[filter_str,' '];
for i = 1:(length(rejected) - 1)
  filter_str = strcat([filter_str,int2str(rejected(i)),',']);
end
filter_str = strcat([filter_str,int2str(rejected(length(rejected)))]);

